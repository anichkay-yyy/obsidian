// Generated by pwa-lib — do not edit manually
const CACHE_VERSION = 'v1770599812964';
const KNOWN_CACHES = ['api-cache', 'images', 'fonts', 'static', 'pages', 'api-cache', 'images', 'fonts'];

self.addEventListener('install', (event) => {
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(keys =>
      Promise.all(
        keys
          .filter(key => !KNOWN_CACHES.includes(key) && key !== PRECACHE_NAME)
          .map(key => caches.delete(key))
      )
    ).then(() => self.clients.claim())
  );
});

const PRECACHE_NAME = 'precache-v1';
const PRECACHE_URLS = [];


// --- Utility functions ---
function matchRoute(pattern, url) {
  const path = new URL(url).pathname;
  // Convert glob pattern to regex
  const regexStr = '^' + pattern
    .replace(/\*\*/g, '§DOUBLESTAR§')
    .replace(/\*/g, '[^/]*')
    .replace(/§DOUBLESTAR§/g, '.*')
    .replace(/\{([^}]+)\}/g, (_, exts) => '(' + exts.split(',').join('|') + ')')
    + '$';
  return new RegExp(regexStr).test(path);
}

function isExpired(response, maxAgeSec) {
  const cacheTime = response.headers.get('sw-cache-time');
  if (!cacheTime) return false;
  return (Date.now() - Number(cacheTime)) > maxAgeSec * 1000;
}

async function trimCache(cacheName, maxEntries) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  if (keys.length > maxEntries) {
    for (let i = 0; i < keys.length - maxEntries; i++) {
      await cache.delete(keys[i]);
    }
  }
}

// --- Strategy implementations ---

async function networkFirst_api_cache(request) {
  const cache = await caches.open('api-cache');
  try {
    const response = await Promise.race([
      fetch(request),
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 3000))
    ]);
    if (response.ok) {
      await cache.put(request, response.clone());
      
    }
    return response;
  } catch {
    const cached = await cache.match(request);
    if (cached) return cached;
    return new Response('Network error', { status: 408 });
  }
}

async function cacheFirst_images(request) {
  const cache = await caches.open('images');
  const cached = await cache.match(request);
  if (cached) {
    if (!isExpired(cached, 2592000)) return cached;
  }
  try {
    const response = await fetch(request);
    if (response.ok) {
      const clone = response.clone();
      const headers = new Headers(clone.headers); headers.set('sw-cache-time', Date.now().toString());
      await cache.put(request, new Response(await clone.blob(), { headers }));
      await trimCache('images', 100);
    }
    return response;
  } catch {
    if (cached) return cached;
    return new Response('Network error', { status: 408 });
  }
}

async function cacheFirst_fonts(request) {
  const cache = await caches.open('fonts');
  const cached = await cache.match(request);
  if (cached) {
    if (!isExpired(cached, 31536000)) return cached;
  }
  try {
    const response = await fetch(request);
    if (response.ok) {
      const clone = response.clone();
      const headers = new Headers(clone.headers); headers.set('sw-cache-time', Date.now().toString());
      await cache.put(request, new Response(await clone.blob(), { headers }));
      
    }
    return response;
  } catch {
    if (cached) return cached;
    return new Response('Network error', { status: 408 });
  }
}

async function staleWhileRevalidate_static(request) {
  const cache = await caches.open('static');
  const cached = await cache.match(request);
  const fetchPromise = fetch(request).then(response => {
    if (response.ok) {
      cache.put(request, response.clone());
      trimCache('static', 50);
    }
    return response;
  }).catch(() => cached);
  return cached || fetchPromise;
}

async function networkFirst_pages(request) {
  const cache = await caches.open('pages');
  try {
    const response = await Promise.race([
      fetch(request),
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 3000))
    ]);
    if (response.ok) {
      await cache.put(request, response.clone());
      
    }
    return response;
  } catch {
    const cached = await cache.match(request);
    if (cached) return cached;
    return new Response('Network error', { status: 408 });
  }
}

async function staleWhileRevalidate_rt_stalewhilerevalidate(request) {
  const cache = await caches.open('rt-stalewhilerevalidate');
  const cached = await cache.match(request);
  const fetchPromise = fetch(request).then(response => {
    if (response.ok) {
      cache.put(request, response.clone());
      
    }
    return response;
  }).catch(() => cached);
  return cached || fetchPromise;
}

// --- Fetch handler ---
self.addEventListener('fetch', (event) => {
  const url = event.request.url;

  // Skip non-GET requests
  if (event.request.method !== 'GET') return;

  // Skip chrome-extension and other non-http schemes
  if (!url.startsWith('http')) return;

  if (matchRoute('/api/**', url)) { event.respondWith(networkFirst_api_cache(event.request)); return; }
  if (matchRoute('*.{png,jpg,jpeg,gif,svg,webp,ico}', url)) { event.respondWith(cacheFirst_images(event.request)); return; }
  if (matchRoute('*.{woff,woff2,ttf,eot}', url)) { event.respondWith(cacheFirst_fonts(event.request)); return; }
  if (matchRoute('*.{css,js}', url)) { event.respondWith(staleWhileRevalidate_static(event.request)); return; }
  if (matchRoute('/**', url)) { event.respondWith(networkFirst_pages(event.request)); return; }
  if (matchRoute('/api/**', url)) { event.respondWith(networkFirst_api_cache(event.request)); return; }
  if (matchRoute('*.{png,jpg,jpeg,gif,svg,webp,ico}', url)) { event.respondWith(cacheFirst_images(event.request)); return; }
  if (matchRoute('*.{woff,woff2,ttf,eot}', url)) { event.respondWith(cacheFirst_fonts(event.request)); return; }
  if (matchRoute('/**', url)) { event.respondWith(staleWhileRevalidate_rt_stalewhilerevalidate(event.request)); return; }
});
